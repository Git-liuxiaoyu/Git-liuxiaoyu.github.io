<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Eureka</title>
      <link href="/2021/10/12/Spring%20Colud%20Eureka/"/>
      <url>/2021/10/12/Spring%20Colud%20Eureka/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Colud-Eureka"><a href="#Spring-Colud-Eureka" class="headerlink" title="Spring Colud Eureka"></a>Spring Colud Eureka</h1><h2 id="1、Eureka简介"><a href="#1、Eureka简介" class="headerlink" title="1、Eureka简介"></a>1、Eureka简介</h2><p>服务注册与发现主要包括两个部分：服务端（Eureka Server）和客户端（Eureka Client）</p><ul><li><p><strong>服务端</strong>(Eureka Server)： 一个公共服务，为Client提供服务注册和发现的功能，维护注册到自身的Client的相关信息，同时提供接口给Client获取注册表中其他服务的信息，使得动态变化的Client能够进行服务间的相互调用。</p></li><li><p><strong>客户端</strong>(Eureka Client)： Client将自己的服务信息通过一定的方式登记到Server上，并在正常范围内维护自己信息一致性，方便其他服务发现自己，同时可以通过Server获取到自己依赖的其他服务信息，完成服务调用，还内置了负载均衡器，用来进行基本的负载均衡</p></li></ul><h2 id="2、client功能和server功能"><a href="#2、client功能和server功能" class="headerlink" title="2、client功能和server功能"></a>2、client功能和server功能</h2><h4 id="2-1-client功能"><a href="#2-1-client功能" class="headerlink" title="2.1 client功能"></a>2.1 client功能</h4><ul><li><p>注册：每个微服务启动时，将自己的网络地址等信息注册到注册中心，注册中心会存储（内存中）这些信息。</p></li><li><p>获取服务注册表：服务消费者从注册中心，查询服务提供者的网络地址，并使用该地址调用服务提供者，为了避免每次都查注册表信息，所以client会定时去server拉取注册表信息到缓存到client本地。</p></li><li><p>心跳：各个微服务与注册中心通过某种机制（心跳）通信，若注册中心长时间和服务间没有通信，就会注销该实例。</p></li><li><p>调用：实际的服务调用，通过注册表，解析服务名和具体地址的对应关系，找到具体服务的地址，进行实际调用。</p></li></ul><h4 id="2-2-server注册中心功能"><a href="#2-2-server注册中心功能" class="headerlink" title="2.2 server注册中心功能"></a>2.2 server注册中心功能</h4><ol><li>服务注册表：记录各个微服务信息，例如服务名称，ip，端口等。</li><li>注册表提供 查询API（查询可用的微服务实例）和管理API（用于服务的注册和注销）。</li><li>服务注册与发现：注册：将微服务信息注册到注册中心。发现：查询可用微服务列表及其网络地址。</li><li>服务检查：定时检测已注册的服务，如发现某实例长时间无法访问，就从注册表中移除。</li></ol><h2 id="3、pom依赖"><a href="#3、pom依赖" class="headerlink" title="3、pom依赖"></a>3、pom依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4、注册中心的application-yml配置"><a href="#4、注册中心的application-yml配置" class="headerlink" title="4、注册中心的application.yml配置"></a>4、注册中心的application.yml配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">$&#123;spring.cloud.client.ip-address&#125;</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;</span> <span class="comment"># 微服务的唯一标识</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">4</span> <span class="comment"># 1. 缩短心跳上报周期</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">12</span> <span class="comment"># 2. 缩短有效期时长</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment"># 不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span>  <span class="comment"># 不从 Eureka Server 获取服务的注册信息</span></span><br><span class="line">    <span class="comment">#设置服务注册中心的URL，用于client和server端交流</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">      <span class="attr">enable-self-preservation:</span> <span class="literal">true</span> <span class="comment">#关闭自我保护模式。（新版本中官方不建议关闭，会有告警）</span></span><br><span class="line">      <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">6000</span> <span class="comment"># 缩短清理周期。（其实默认值也行）</span></span><br><span class="line">      <span class="attr">renewal-threshold-update-interval-ms:</span> <span class="number">15</span> <span class="string">*</span> <span class="number">60</span> <span class="string">*</span> <span class="number">1000</span> <span class="comment">#如果在 15 分钟内超过 85% 的客户端节点都没有正常的心跳，那么 Eureka 就认为这些客户端与注册中心出现了网络故障</span></span><br><span class="line">      <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span> </span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><h2 id="5、client的application-yml配置"><a href="#5、client的application-yml配置" class="headerlink" title="5、client的application.yml配置"></a>5、client的application.yml配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#注册中心</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #设置服务注册中心的URL</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka/</span><br><span class="line">  #服务名</span><br><span class="line">  instance:</span><br><span class="line">    appname: mxn</span><br></pre></td></tr></table></figure><h2 id="6、注解"><a href="#6、注解" class="headerlink" title="6、注解"></a>6、注解</h2><ol><li>启动类上添加此注解标识该服务为注册中心      <strong>@EnableEurekaServer</strong></li><li>启动类上添加此注解标识该服务为客户端   <strong>@EnableDiscoveryClient</strong></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Zuul</title>
      <link href="/2021/10/12/Spring%20Cloud%20Zuul/"/>
      <url>/2021/10/12/Spring%20Cloud%20Zuul/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Cloud-Zuul"><a href="#Spring-Cloud-Zuul" class="headerlink" title="Spring Cloud Zuul"></a>Spring Cloud Zuul</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p><strong>为什么需要使用微服务网关？</strong></p><p>微服务网关最重要的功能就是可以实现路由转发和过滤。在微服务架构体系中，一个项目会包含多个微服务，并且每个微服务会独立部署，提供不同的网络地址，客户端可以通过调用多个微服务接口完成一个用户请求，这样会带来以下几个明显问题：</p><ul><li>客户端多次请求不同的微服务，增加了客户端的复杂性。</li><li>每个服务都需要独立认证，过于繁琐、复杂。</li><li>存在跨域请求，在特殊场景下处理会比较复杂。</li><li>难以重构。</li></ul><p>通过网关就可以解决以上问题。</p><p>微服务网关时存在于客户端和服务端的中间层，客户端发来的所有请求都会先通过微服务网关再转发到真正的微服务进行处理。</p><p>Zuul 是 Netflix 的一个开源组件，是通过 Servlet 实现的。Zuul 作为 Spring Cloud 中的服务网关组件，能够通过与 Eureka 进行整合，将自身注册到 Ereka Server 中，与 Eureka、Ribbon、Hystrix 等进行组合，同时从 Eureka 中获得其它微服务实例的信息。</p><p>通过这样的设计，能够把网关和服务管理整合到一起，让 Zuul 可以获取到服务注册信息，结合 Ribbon、Hystrix 等更好地实现路由转发、负载均衡等功能。</p><h2 id="2、pom依赖"><a href="#2、pom依赖" class="headerlink" title="2、pom依赖"></a>2、pom依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、注解"><a href="#3、注解" class="headerlink" title="3、注解"></a>3、注解</h2><p>创建 EurekaZuulApplication 启动类，并增加 <strong>@EnableZuulProxy</strong> 注解</p><h2 id="4、配置"><a href="#4、配置" class="headerlink" title="4、配置"></a>4、配置</h2><blockquote><p>网关项目（Zuul）和注册中心项目（Eureka Server）一样，都是独立的项目，是独立运行的。而且，网关项目还是一个 Eureka Client 项目，它需要连接、注册到 Eureka Server 。</p></blockquote><ul><li>添加 bootstrap.yml 配置文件：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:8761/eureka/</span></span><br></pre></td></tr></table></figure><ul><li>添加 <strong>application.yml</strong> 配置文件:</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7600</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">zuul-gateway</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">$&#123;spring.cloud.client.ip-address&#125;</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">eureka-client-employee:</span> <span class="string">/employee/**</span></span><br><span class="line">    <span class="attr">eureka-client-department:</span> <span class="string">/department/**</span></span><br><span class="line">    <span class="comment">#还可以这么配置</span></span><br><span class="line"><span class="comment"># zuul:</span></span><br><span class="line">  <span class="comment"># routes:</span></span><br><span class="line">   <span class="comment"># <span class="doctag">xxx:</span></span></span><br><span class="line">     <span class="comment"># path: /employee/**</span></span><br><span class="line">     <span class="comment"># service-id: eureka-client-employee</span></span><br><span class="line">   <span class="comment"># yyy:</span></span><br><span class="line">     <span class="comment"># path: /department/**</span></span><br><span class="line">     <span class="comment"># service-id: eureka-client-department</span></span><br></pre></td></tr></table></figure><p>这里的核心配置就是 <code>zuul.routes</code> 这段：</p><ul><li>当 zuul 收到以 <code>/employee</code> 开头的请求时，将转发至 eureka-client-employee 微服务，至于 eureka-client-employee 微服务的具体地址再哪，zuul 会自己去查从 Eureka Server 那里下载的注册表；</li><li>当 zuul 收到以 <code>/department</code> 开头的请求时，将转发至 eureka-client-department 微服务，至于 eureka-client-department 微服务的具体地址在哪，zuul 会自己去查从 Eureka Server 那里下载的注册表。</li></ul><p><strong>注意</strong> </p><blockquote><p>eureka-client-employee 和 eureka-client-department 对外暴露的路径中，不强求有 <code>/employee</code>、<code>/department</code> 。</p></blockquote><p>有 2 点需要指出：</p><ul><li><code>路由名</code> 是程序员自定义的名字，是一个任意内容。</li><li>上一章的写法，本质上是上述写法的简写。即，<code>zuul.routes.&lt;serviceId&gt;=&lt;path&gt;</code> 。</li></ul><p><strong>默认配置规则</strong></p><p>zuul 使用的就是默认的路由规则：以服务的『<strong>服务名</strong>』作为前缀路径。</p><p><strong>即：</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">yyy:</span>      </span><br><span class="line">      <span class="attr">path:</span> <span class="string">/eureka-client-department/**</span></span><br><span class="line">      <span class="attr">service-id:</span> <span class="string">eureka-client-department</span></span><br><span class="line">      <span class="comment">#即简写形式为： eureka-client-employee: /employee-client-employee/**</span></span><br></pre></td></tr></table></figure><p>如果不想使用默认的路由规则，就可以在配置文件中加入下列内容，即可关闭所有默认的路由规则：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">ignored-services:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong>在关闭默认的路由配置之后，此时需要在配置文件中逐个为需要路由的服务添加映射规则。</p><h2 id="5、路由截取"><a href="#5、路由截取" class="headerlink" title="5、路由截取"></a>5、路由截取</h2><p>默认情况下，zuul 会截取、删除掉你访问它（zuul）的 URI 的第一部分，而后再路由到目标服务。例如，</p><p>你访问的 zuul 的 URI 是 <code>/department/xxx</code>，根据路由配置，请求路由到部门服务后，触发的是 <code>/xxx</code> URI 。</p><p>如果你不需要这种默认的路由截取的功能，你可以通过 <code>strip-prefix</code> 配置项进行配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">xxx:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/employee/**</span></span><br><span class="line">      <span class="attr">service-id:</span> <span class="string">eureka-client-employee</span></span><br><span class="line">      <span class="attr">strip-prefix:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>补充 ：</p><blockquote><p>在 Zuul 中，路由表达式采用了 Ant 风格定义。</p><p>Ant 风格的路由表达式共 有 3 种通配符：</p></blockquote><table><thead><tr><th>通配符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>？</td><td>匹配任意单个字符</td><td>/xxx/?</td></tr><tr><td>*</td><td>匹配任意数量的字符</td><td>/xxx/*</td></tr><tr><td>**</td><td>匹配任意数量的字符， 包括多级目录</td><td>/xxx/**</td></tr></tbody></table><p>为了让用户更灵活地使用路由配置规则，zuul 还提供了一个忽略表达式参数 <code>zuul.ignored-patterns</code>，该参数用来设置不被网关进行路由的 RUL 表达式。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">ignored-patterns:</span> <span class="string">/**/xxx/**</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">eureka-client-employee:</span> <span class="string">/employee/**</span></span><br><span class="line">    <span class="attr">eureka-client-department:</span> <span class="string">/department/**</span></span><br></pre></td></tr></table></figure><h2 id="6、服务拦截"><a href="#6、服务拦截" class="headerlink" title="6、服务拦截"></a>6、服务拦截</h2><p>前面我们提到，服务网关还有个作用就是接口的安全性校验，这个时候我们就需要通过 zuul 进行统一拦截，zuul 通过继承过滤器 <strong>ZuulFilter</strong> 进行处理，下面请看具体用法。</p><p>新建一个类 <strong>ApiFilter</strong>并继承 <strong>ZuulFilter</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;pre&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">    <span class="comment">// 这里写校验代码。例如 JWT 的校验。</span></span><br><span class="line">    RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">    HttpServletRequest request = context.getRequest();</span><br><span class="line">    HttpServletResponse response = context.getResponse();</span><br><span class="line">    response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    response.setHeader(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;请求进入过滤器，访问的 url：&#123;&#125;，访问的方法：&#123;&#125;&quot;</span>, </span><br><span class="line">                request.getRequestURL(), </span><br><span class="line">                request.getMethod());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据需要获取请求中的参数</span></span><br><span class="line">    String token = request.getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> random = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (random % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      log.info(<span class="string">&quot;请求不通过过滤器&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;token is invalid.&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据业务逻辑，本次请求就【到此为止】，不要再向下传递了。</span></span><br><span class="line">      context.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">      context.setResponseStatusCode(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      log.info(<span class="string">&quot;请求通过过滤器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><strong>filterType</strong> 为过滤类型，可选值有<ul><li>pre：在 Zuul 按照规则路由到下级服务之前执行。如果需要对请求进行预处理，比如鉴权、限流等，都应该考虑在此类 Filter 中实现。</li><li>route：这类 Filter 是 Zuul 路由动作的执行者。我们通常不会实现这类路由。</li><li>post：这类 Filter 是在源服务返回结果或者异常信息发生后执行的，如果需要对返回信息做一些处理，则在此类 Filter 进行处理。</li><li>error：在整个路由环节中如果发生异常，则会进入 error Filter，可做全局异常处理。</li></ul></li><li><strong>filterOrdery</strong> 为过滤的顺序，如果有多个过滤器，则数字越小越先执行</li><li><strong>shouldFilter</strong> 表示是否过滤。它的返回值决定了该 Filter 是否执行，可以作为开关来使用。不过，通常它都是返回 true，『开关』的问题有专门的配置项进行配置。</li><li><strong>run</strong> 为过滤器执行的具体逻辑，在这里可以做很多事情，比如:权限判断、合法性校验等。</li></ul><p>启动 gateway，在浏览器输入地址: <a href="http://localhost:8080/api/hello%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%BB%A5%E4%B8%8B%E7%95%8C%E9%9D%A2%EF%BC%9A">http://localhost:8080/api/hello，可以看到以下界面：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token is invalid</span><br></pre></td></tr></table></figure><p>再通过浏览器输入地址: <a href="http://localhost:8080/api/index?token=12345%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%BB%A5%E4%B8%8B%E7%95%8C%E9%9D%A2">http://localhost:8080/api/index?token=12345，可以看到以下界面</a>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">端口: 8762</span><br></pre></td></tr></table></figure><h2 id="7-禁用-zuul-过滤器"><a href="#7-禁用-zuul-过滤器" class="headerlink" title="7. 禁用 zuul 过滤器"></a>7. 禁用 zuul 过滤器</h2><p>Spring Cloud 默认为 zuul 编写并启动了一些过滤器，这些过滤器都放在 <code>org.springframework.cloud.netflix.zuul.filters</code> 包下。</p><p>如果需要禁用某个过滤器，只需要设置 <code>zuul.&lt;SimpleClassName&gt;.&lt;filterType&gt;.disabled=true</code>，就能禁用名为 <code>&lt;SimpleClassName&gt;</code> 的过滤器。例如:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">名为</span> <span class="string">&lt;SimpleClassName&gt;</span> <span class="string">的过滤器。例如:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">JwtFilter:</span></span><br><span class="line">    <span class="attr">pre:</span></span><br><span class="line">      <span class="attr">disable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上述配置就禁用掉了我们自定义的 JwtFilter 。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenFeign</title>
      <link href="/2021/10/12/Spring%20Cloud%20OpenFeign/"/>
      <url>/2021/10/12/Spring%20Cloud%20OpenFeign/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Cloud-OpenFeign"><a href="#Spring-Cloud-OpenFeign" class="headerlink" title="Spring Cloud OpenFeign"></a>Spring Cloud OpenFeign</h1><h2 id="1、OpenFeign简介"><a href="#1、OpenFeign简介" class="headerlink" title="1、OpenFeign简介"></a>1、OpenFeign简介</h2><blockquote><ul><li>feign是一个声明式web服务客户端，让编写web客户服务端变得非常简单。只需要创建一个接口并在接口添加注解即可。</li><li>feign旨在使编写Java Http客户端变得更容易。</li></ul></blockquote><h3 id="1-1、Feign集成了Ribbon"><a href="#1-1、Feign集成了Ribbon" class="headerlink" title="1.1、Feign集成了Ribbon"></a>1.1、Feign集成了Ribbon</h3><blockquote><p>利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。</p><p>而与Ribbon不同的是，通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用</p></blockquote><h2 id="2、pom依赖"><a href="#2、pom依赖" class="headerlink" title="2、pom依赖"></a>2、pom依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、application-yml配置"><a href="#3、application-yml配置" class="headerlink" title="3、application.yml配置"></a>3、application.yml配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-client-consumer-feign</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:8761/eureka</span></span><br></pre></td></tr></table></figure><h2 id="4、注解"><a href="#4、注解" class="headerlink" title="4、注解"></a>4、注解</h2><blockquote><p><strong>@EnableFeignClients</strong>    必须要在启动类加入这个注解，以开启 OpenFeign</p></blockquote><h2 id="5、用法"><a href="#5、用法" class="headerlink" title="5、用法"></a>5、用法</h2><p><strong>首先创建一个接口 ApiService（名字任意），并且通过注解配置要调用的服务地址</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;eureka-client-producer&quot;)</span>  <span class="comment">// 看这里，看这里，看这里</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@GetMapping(value = &quot;/hello&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>@FeignClient</strong> 注解的 <strong>value</strong> 属性的值是服务提供者在 Eureka Server 上所注册的名字</li></ul><p> <strong>注意</strong></p><blockquote><p style=" color: #1140e8;">一个服务只能被一个类绑定，不能让多个类绑定同一个远程服务，否则，会在启动项目是出现『已绑定』异常。</p></blockquote><p>使用时候调用这个接口就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> ApiService apiService;</span><br><span class="line">  </span><br><span class="line">  apiService.hello(<span class="string">&quot;tom&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="6、OpenFeign配置"><a href="#6、OpenFeign配置" class="headerlink" title="6、OpenFeign配置"></a>6、OpenFeign配置</h2><p>OpenFeign 本身也具备重试能力，在早期的 Spring Cloud 中，OpenFeign 使用的是 feign.Retryer.Default#Default() ，重试 5 次。但 OpenFeign 整合了 Ribbon ，Ribbon 也有重试的能力，此时，就可能会导致行为的混乱。（总重试次数 = OpenFeign 重试次数 x Ribbon 的重试次数，这是一个笛卡尔积。）</p><p>后来 Spring Cloud 意识到了此问题，因此做了改进，将 OpenFeign 的重试改为 feign.Retryer#NEVER_RETRY ，即，<strong>默认关闭</strong> 。</p><p>所以，OpenFeign 对外表现出的超时和重试的行为，实际上是 Ribbon 的超时和超时重试行为。我们在项目中进行的配置，也都是配置 Ribbon 的超时和超时重试。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局配置</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">readTimeout:</span> <span class="number">1000</span>     <span class="comment"># 请求处理的超时时间</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">5</span>     <span class="comment"># 最大重试次数</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span>   <span class="comment"># 切换实例的重试次数</span></span><br><span class="line">  <span class="comment"># 对所有请求开启重试，而非 get 请求。一般不会开启这个功能。</span></span><br><span class="line">  <span class="comment"># okToRetryOnAllOperations: true</span></span><br></pre></td></tr></table></figure><p>也可以指定对某个特定服务的超时和超时重试：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对 SERVICE-PRODUCER 的设置</span></span><br><span class="line"><span class="attr">SERVICE-PRODUCER:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">readTimeout:</span> <span class="number">3000</span></span><br><span class="line">    <span class="attr">MaxAutoRetries:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p style=" color: #1140e8;">本质上是 OpenFeign 所使用的 RestTemplate 替换底层 HTTP 实现。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hystrix</title>
      <link href="/2021/10/12/Spring%20Colud%20Hystrix/"/>
      <url>/2021/10/12/Spring%20Colud%20Hystrix/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Colud-Hystrix"><a href="#Spring-Colud-Hystrix" class="headerlink" title="Spring Colud Hystrix"></a>Spring Colud Hystrix</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>Hystrix 是 Netflix 公司推出的一款针对分布式系统延迟和容错的开源库，其设计目的是通过添加延迟容忍和容错逻辑，从而控制分布式服务之间的交互。</p><p>Hystrix 封装了微服务调用过程中的每一个依赖，使每个依赖彼此隔离，当延迟情况发生时，它会被限制在资源中，并包含回退（fallback）逻辑，该逻辑决定在依赖发生任何类型故障时应做出何种响应。</p><p>Hystrix 的目标是阻止级联故障，对通过第三方客户端访问的依赖的延迟和故障进行保护和访问。Hystrix 实现这一目标的大致思路如下：</p><ol><li>将外部依赖的访问请求封装在独立的线程中，进行资源隔离。</li><li>对于超出设定阈值的服务调用，直接进行超时处理，不允许其消耗过长时间而导致线程阻塞。</li><li>每个依赖服务维护一个独立的线程池，一旦线程池满了，直接拒绝服务调用。</li><li>统计依赖服务调用的成功次数、失败次数、拒绝次数、超时次数等结果。</li><li>在一段时间内，如果服务调用的异常次数超过一定的阈值，就会触发熔断器，停止对特定服务的所有请求。在一定时间内对服务降级，一段时间之后自动尝试恢复。</li><li>如果某个服务出现调用失败、被拒绝、超时等异常情况，就会自动调用 fallback 降级机制。</li></ol><h2 id="2、容错"><a href="#2、容错" class="headerlink" title="2、容错"></a>2、容错</h2><p>微服务架构的系统通常会包含多个微服务，各个微服务可能部署在不同的机器上并通过网络进行通信，那么就不可避免会遇到 <code>网络请求超时</code>、<code>微服务不可用</code> 等问题，这就会进一步引起依赖它的微服务不可用，这样不断引发服务故障的现象称为『<strong>雪崩效应</strong>』，最终的结果是整个应用系统瘫痪。</p><p>针对上述问题，处理容错有以下常用手段：</p><ul><li><p><strong>超时重试</strong></p><blockquote><p>在 HTTP 请求中通常会设置请求的超时时间，超过一定时间后我们（主调方）就会断开连接（不再等待被调方的响应）。</p><p>在设置『超时』的同时，一般会配合设置请求『重试』，也就是在请求失败时再次自动发起请求，但要注意重试次数不能设置太多。</p><p>具体的超时时间和重试次数需要结合具体的业务来指定。</p></blockquote></li><li><p><strong>熔断器</strong></p><blockquote><p>使用熔断器模式，如果请求出现异常，所有请求都会直接返回，而不会等待或阻塞，这样可以减少资源的浪费。</p><p>熔断器所造成的这种现象也叫『快速失败』。</p><p>熔断器还有一种半开的状态，当熔断器发现异常后会进入半开状态，此时它会『放行一个请求』来检测被调系统是否已经恢复，如果请求调用成功，则代表被调系统已经恢复正常，那么就会关掉熔断器，否则继续打开。</p></blockquote></li><li><p><strong>限流</strong></p><blockquote><p>由于被调系统处理能力时有限，如果请求方访问量过大会导致被调系统不可用。除了可以增加机器的物理配置，也可以对系统进行限流。常见的限流措施有控制并发数量</p></blockquote></li></ul><h2 id="3、pom依赖"><a href="#3、pom依赖" class="headerlink" title="3、pom依赖"></a>3、pom依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4、注解"><a href="#4、注解" class="headerlink" title="4、注解"></a>4、注解</h2><p>在服务（使用者的）入口启动类上面加上 <strong>@EnableHystrix</strong> 或 <strong>@EnableCircuitBreaker</strong> 注解，表示激活熔断器的默认配置。</p><h2 id="5、application-yml配置"><a href="#5、application-yml配置" class="headerlink" title="5、application.yml配置"></a>5、application.yml配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">3000</span> <span class="comment"># 超时和重试 默认 1000，短得有点过分了。</span></span><br><span class="line">      <span class="attr">metrics:</span></span><br><span class="line">        <span class="attr">rollingStats:</span></span><br><span class="line">          <span class="attr">timeInMilliseconds:</span> <span class="number">10000</span></span><br><span class="line">      <span class="attr">circuitBreaker:</span></span><br><span class="line"><span class="comment">#       enabled: true     # 默认值即为 true</span></span><br><span class="line">        <span class="attr">requestVolumeThreshold:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">errorThresholdPercentage:</span> <span class="number">60</span></span><br><span class="line">        <span class="attr">sleepWindowInMilliseconds:</span> <span class="number">300000</span></span><br><span class="line">      <span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#OpenFeign 已经整合了 Hystrix，但是默认情况下并未将其激活使用</span></span><br></pre></td></tr></table></figure><ul><li><strong>metrics.rollingStats.timeInMilliseconds</strong> ：统计窗口时间，单位毫秒。默认 <code>10000</code>，即 10 秒。</li><li><strong>circuitBreaker.enabled</strong>： 是否启用熔断器。默认值为 <code>true</code> 。</li><li><strong>circuitBreaker.requestVolumeThreshold</strong> ：窗口期内发生 N 个失败就触发熔断。断路器由『<strong>关闭</strong>』状态进入『<strong>开启</strong>』状态，默认值为 <code>20</code> 。</li><li><strong>circuitBreaker.errorThresholdPercentage</strong> ： 窗口期内发生 N% 的错误就触发熔断。断路器由『<strong>关闭</strong>』状态进入『<strong>开启</strong>』状态。默认值为 <code>50</code> ，即 50% 失败。</li><li><strong>circuitBreaker.sleepWindowInMilliseconds</strong> ：熔断后 N 毫秒才开始尝试恢复。断路器由『<strong>开启</strong>』状态转变为『<strong>半开</strong>』状态。默认值 5000 ，即 5 秒钟。</li></ul><h2 id="6、使用"><a href="#6、使用" class="headerlink" title="6、使用"></a>6、使用</h2><p>全局配置完成之后，想让哪一个方法实现断路器功能，就在哪一个方法上加上注解 <strong>@HystrixCommand</strong> 。注意，这里的『<strong>方法</strong>』指的是调用了 Feign 或 RestTeamplte 的方法，通常就是 @Service 中的方法。</p><blockquote><p style=" color: #1140e8;">@HystrixCommand 注解的背后也是 Spring AOP 动态代理思想。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;demo1FallBack&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String url = <span class="string">&quot;http://MICROSERVICE-PRODUCER/&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> template.postForObject(url, <span class="keyword">null</span>, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始情况下，由于『服务提供者』是可用的，因此，『服务消费者』对外提供的服务也是可用的。</p><p>可通过 postman 验证。结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;10086&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;do something 成功&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现将『服务提供者』关闭，造成『<strong>服务不可用</strong>』情况。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;日期时间&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;Internal Server Error&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;... timed-out and fallback failed.&quot;</span>,    看这里，看这里，看这里</span><br><span class="line">    <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;...&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的响应结果，提供给用户显然是不够友好的。上面的提示信息有两层含义：</p><ul><li>服务熔断被触发，也就是断路器处于开启状态；</li><li>断路器被触发之后，访问 fallback 方法，但是这个 fallback 方法我们之前没有定义。</li></ul><p>当服务提供者故障触发熔断机制，此时我们可以预先提供一个处理方法，作为降级后的执行方法一般叫 <strong>fallback</strong> ，fallback 方法返回值一般是设置的默认值或者来自缓存，或者是一些友好提示信息。</p><p>以下写法仅作了解，后续我们主要是结合 OpenFeign 使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;demo2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String url = <span class="string">&quot;http://SELF-DEPARTMENT/&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> template.postForObject(url, <span class="keyword">null</span>, String.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">demo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个时候，当 demo1（中的 RestTemplate）执行失败时，demo2 方法会执行，demo2 的返回值将作为 demo1 的返回值的替代返回。</p></blockquote><h2 id="7、Feign-指定-fallback"><a href="#7、Feign-指定-fallback" class="headerlink" title="7、Feign 指定 fallback"></a>7、Feign 指定 fallback</h2><blockquote><p>在接口注解  <strong>==@FeignClient==</strong> 中指定 fallback 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;producer-mail&quot;, fallback = 看这里)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式的 fallback 配置中，需要你『<strong>额外地</strong>』为接口去编写一个实现类。显而易见，这个实现类中的各个方法，就是接口中各个远程调用方法的对应的 fallback 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">// 别忘了这里</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailServiceFallback</span> <span class="keyword">implements</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">send</span><span class="params">(String to, String content)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        result.put(<span class="string">&quot;code&quot;</span>, <span class="string">&quot;10086&quot;</span>);</span><br><span class="line">        result.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;内部错误，请稍后再试&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，但凡是调用 MailService 的服务的方法，出现调用失败时，都会使用这个类下的各个方法作为 fallback 。</p><h2 id="8、小节"><a href="#8、小节" class="headerlink" title="8、小节"></a>8、小节</h2><p>Hystrix、OpenFeign、Ribbon 它们三者的调用层次顺序是</p><blockquote><p>hystrix </p><p>​    └── openfeign    </p><p>​            └── ribbon</p><p>最底层的是 ribbon ，因此是 ribbon 先进行重试，如果重试不成功（抛异常），hystrix 会再次调用 openfeign 发请求，重试。</p></blockquote><p>而由于 Ribbon 的超时重试次数是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 + MaxAutoRetries ) x (1 + MaxAutoRetriesNextServer)</span><br></pre></td></tr></table></figure><p>因此，理论上 Hystrix 的超时阈值应该：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">超时阈值 &gt; (ribbon 的最大重试次数 x readTimeout)</span><br></pre></td></tr></table></figure><p>这样，才能保证 Ribbon 重试的时候不被 Hystrix 熔断。否则 Hystrix 命令超时后，该命令直接熔断，Ribbon 的重试工作就会被强行终止，导致出现『Ribbon 还想抢救一下，但是 Hystrix 决定放弃的情况』。当然，这样不是不可以，只是显得不科学。</p><h4 id="8-1-其他"><a href="#8-1-其他" class="headerlink" title="8.1 其他"></a>8.1 其他</h4><p>除了线程池之外，Hystrix 还可以使用信号量来作资源隔离。</p><p>使用信号量隔离需要显示地将属性 execution.isolation.strategy 设置为 <code>semaphore</code>（它和 thread 一样，都是定义在 ExecutionIsolationStrategy 枚举中的），同时配置信号量个数，默认为 10 。</p><p>客户端需向依赖服务发起请求时，首先要获取一个信号量才能真正发起调用，由于信号量的数量有限，当并发请求量超过信号量个数时，后续的请求都会直接拒绝，进入 fallback 流程。</p><p>即，发起请求是信号量减一，接收到响应后信号量加一。</p><p>信号量隔离主要是通过控制并发请求量，防止请求线程大面积阻塞，从而达到限流和防止雪崩的目的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring事务传播机制和隔离级别</title>
      <link href="/2021/10/11/spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
      <url>/2021/10/11/spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="spring事务传播机制和隔离级别"><a href="#spring事务传播机制和隔离级别" class="headerlink" title="spring事务传播机制和隔离级别"></a>spring事务传播机制和隔离级别</h1><h2 id="1-事务传播机制"><a href="#1-事务传播机制" class="headerlink" title="1.事务传播机制"></a>1.事务传播机制</h2><h3 id="1-1事务传播是什么？"><a href="#1-1事务传播是什么？" class="headerlink" title="1.1事务传播是什么？"></a>1.1事务传播是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假如有A,B两个方法，方法A有事务，方法B无事务。这时，用调用方法A而方法A会调用方法B，无事务方法B就会对A产生影响，相反事务方法A也会对B产生影响。这种影响具体是什么,  就由两个方法所定义的事务传播类型所决定。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201217171633987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pqODk5Mjk2NjU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-2事务传播类型"><a href="#1-2事务传播类型" class="headerlink" title="1.2事务传播类型"></a>1.2事务传播类型</h3><p>事务传播类型有7种<br>    REQUIRED、<br>    SUPPORTS、<br>    MANDATORY、<br>    REQUIRES_NEW、<br>    NOT_SUPPORTED、<br>    NEVER、<br>    NESTED。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也就是说枚举类Propagation是为了结合@Transactional注解使用而设计的，这个枚举里面定义的事务传播行为类型与TransactionDefinition中定义的事务传播行为类型是对应的，所以在使用@Transactional注解时我们就要使用Propagation枚举类来指定传播行为类型，而不直接使用TransactionDefinition接口里定义的属性。</span><br></pre></td></tr></table></figure><h3 id="1-3七种事务传播行为，案例理解"><a href="#1-3七种事务传播行为，案例理解" class="headerlink" title="1.3七种事务传播行为，案例理解"></a>1.3七种事务传播行为，案例理解</h3><h6 id="1-REQUIRED（Spring默认传播事务）"><a href="#1-REQUIRED（Spring默认传播事务）" class="headerlink" title="1.REQUIRED（Spring默认传播事务）"></a>1.REQUIRED（Spring默认传播事务）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">支持当前事务，如果没有事务就创建一个新事务。</span><br><span class="line">假如testA中没有事务，那么就创建一个新的事务，由于调用了testB，所以沿用当前事务，抛出异常时，回滚当前事务，没有任何数据被录入。</span><br><span class="line">testA无事务，所有会被忽略，不会出现回滚，而testB中的事务，会因为抛出异常而被回滚。</span><br></pre></td></tr></table></figure><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1617017777498.png" alt="1617017777498"></p><h6 id="2-SUPPORTS"><a href="#2-SUPPORTS" class="headerlink" title="2.SUPPORTS"></a>2.SUPPORTS</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">支持当前事务，如果不存在则抛出异常（无事务就以无事务的方式处理）</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试层中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    goods(a);  <span class="comment">//添加商品a</span></span><br><span class="line">    testB();   <span class="comment">//调用testB</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    img(b1);  <span class="comment">//添加图片b1</span></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">    img(b2);  <span class="comment">//添加图片b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>商品a和图片b1被录入</strong>，testA中无事务所以直接插入，testB延续A的无事务状态，遇见异常后b2不执行，所以<strong>只录入了商品a和图片b1</strong>.</p><h6 id="3-MANDATORY"><a href="#3-MANDATORY" class="headerlink" title="3.MANDATORY"></a>3.MANDATORY</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">支持当前事务，如果不存在则抛出异常</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试层中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    goods(a);  <span class="comment">//添加商品a</span></span><br><span class="line">    testB();   <span class="comment">//调用testB</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.MANDATORY)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    img(b1);  <span class="comment">//添加图片b1</span></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">    img(b2);  <span class="comment">//添加图片b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只有商品a被录入</strong>，testA无事务所有被录入，而testB中由于没有事务，但是遇见了异常就会全部回滚。</p><h6 id="4-REQUIRES-NEW"><a href="#4-REQUIRES-NEW" class="headerlink" title="4.REQUIRES_NEW"></a>4.REQUIRES_NEW</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建一个事务，如果不存在，就挂起该事务</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试层中</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    goods(a);  <span class="comment">//添加商品a</span></span><br><span class="line">    testB();   <span class="comment">//调用testB</span></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    img(b1);  <span class="comment">//添加图片b1</span></span><br><span class="line">    img(b2);  <span class="comment">//添加图片b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只存储了图片b1和b2</strong>，在执行testB会开启一个新事务，而testA发生的异常会回滚testA中的数据，所以商品a没有存储。<br>如果将testA和testB都设置成REQUIRED，那么所有数据都会回滚不会存储，因为他们都是一个事务下的，<strong>数据都会回滚</strong>。</p><h6 id="5-NOT-SUPPORTED"><a href="#5-NOT-SUPPORTED" class="headerlink" title="5.NOT_SUPPORTED"></a>5.NOT_SUPPORTED</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以非事务方式执行，如果当前事务存在，则挂起当前事务。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试层中</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    goods(a);  <span class="comment">//添加商品a</span></span><br><span class="line">    testB();   <span class="comment">//调用testB</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    img(b1);  <span class="comment">//添加图片b1</span></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">    img(b2);  <span class="comment">//添加图片b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只有图片b1录入</strong>，testA执行，当testB执行时，将testA事务挂起，直接录入了图片b1，但是抛出异常b2未执行。而testA事务出现异常，开始回滚。</p><h6 id="6-NEVER"><a href="#6-NEVER" class="headerlink" title="6.NEVER"></a>6.NEVER</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不使用事务，如果当前事务存在，则抛出异常</span><br><span class="line">很容易理解，就是我这个方法不使用事务，并且调用我的方法也不允许有事务，如果调用我的方法有事务则我直接抛出异常。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试层中</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    goods(a);  <span class="comment">//添加商品a</span></span><br><span class="line">    testB();   <span class="comment">//调用testB</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NEVER)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    img(b1);  <span class="comment">//添加图片b1</span></span><br><span class="line">    img(b2);  <span class="comment">//添加图片b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>没有任何数据录入</strong>，由于testA有事务，调用了没有不允许使用事务的testB，直接抛出异常。</p><h6 id="7-NESTED"><a href="#7-NESTED" class="headerlink" title="7.NESTED"></a>7.NESTED</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果当前事物存在，则嵌套在事务中执行。否则REQUIRED的操作一样（开启一个事务）</span><br></pre></td></tr></table></figure><p>情况1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试层中</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    goods(a);  <span class="comment">//添加商品a</span></span><br><span class="line">    testB();   <span class="comment">//调用testB</span></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">throw</span> Exception; <span class="comment">//抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    img(b1);  <span class="comment">//添加图片b1</span></span><br><span class="line">    img(b2);  <span class="comment">//添加图片b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数据都不会录入</strong>，因为在testMain发生异常时，父事务回滚则子事务也跟着回滚了</p><p>情况2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试层中</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    goods(a);  <span class="comment">//添加商品a</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        testB();    <span class="comment">//调用testB</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>（Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    goods(a2);   <span class="comment">//调用testB</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    img(b1);  <span class="comment">//添加图片b1</span></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">throw</span> Exception; <span class="comment">//抛出异常</span></span><br><span class="line">    img(b2);  <span class="comment">//添加图片b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只有商品a和a2录入</strong>，因为testA事务捕获了异常，testA会正常执行，而testB嵌套中抛出异常会只回滚testB。</p><h2 id="2-隔离级别"><a href="#2-隔离级别" class="headerlink" title="2.隔离级别"></a>2.隔离级别</h2><p>一．数据库事务特性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   数据库事务transaction是组合一系列数据库操作（增删查改）作为一个逻辑处理单元的操作。单元内存ACID四大特性。</span><br><span class="line">|-原子性（Atomicity）:一个事务内所有操作，要么全部成功，要么全部失败。</span><br><span class="line">|-一致性（Consistency）:事务执行完毕后，数据库结果与业务规则一致。如转账业务，无论成功与失败，前后金额总和不变。</span><br><span class="line">|-隔离性（Isolation）:并发的数据库事务操作场景下，各事务间相互隔离，互不影响。</span><br><span class="line">|-持久性（Durability）:事务一旦提交后，事务执行结果永久保留在数据库中。</span><br></pre></td></tr></table></figure><p>二．事务隔离级别</p><h6 id="2-1READ-UNCOMMITTED"><a href="#2-1READ-UNCOMMITTED" class="headerlink" title="2.1READ_UNCOMMITTED"></a>2.1READ_UNCOMMITTED</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">读未提交：一个事务a可以在其他事务b未提交前，读取b操作的数据。这个隔离级别容易造成脏读。</span><br><span class="line">将事务设置为READ_UNCOMMITTED</span><br><span class="line">设置事务隔离级别：</span><br><span class="line">set session transaction isolation leve1 read uncommitted;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">事务a中开始事务，将账号111余额扣除50元，但事务未提交，另外见一个mysql客户端，</span><br><span class="line">开启事务b进行余额查询，查询到111账号余额是50。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事务a rollback撤回，余额回归100元，事务b读到的数据并不是最终的真实数据，即为脏数据</span><br></pre></td></tr></table></figure><h6 id="2-2READ-COMMITTED"><a href="#2-2READ-COMMITTED" class="headerlink" title="2.2READ_COMMITTED"></a>2.2READ_COMMITTED</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读已提交，事务a只能等事务b提交后，才能读取到最新提交后的数据，能解决脏读问题。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从图中操作可以看到，事务b虽然已经改了余额，但尚未提交，事务a读取到提交前的数据，这就解决了脏读的问题，事务b提交后，事务a再次查询，得到提交后的数据。可以看出，前后两次事务a查询得到的数据说不一致的，造成了不可重复读的问题。</span><br></pre></td></tr></table></figure><h6 id="2-3REPEATABLE-ABLE（MySQL默认隔离级别）"><a href="#2-3REPEATABLE-ABLE（MySQL默认隔离级别）" class="headerlink" title="2.3REPEATABLE_ABLE（MySQL默认隔离级别）"></a>2.3REPEATABLE_ABLE（MySQL默认隔离级别）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可重复读，顾名思义，事务a开始对一数据操作后,到提交前这一段时间内，就算事务b对同一数据进行修改并提交，数据a所读取的某条数据的值都是一致的。也就是说事务a开始到提交这段期间所读取的数据，不收外界影响，形成可重复读。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可重复读没能解决幻读的问题。即事务a在一个事务内多次查询，有可能查询到不同条数据记录。原因为若事务a开启事务到事务提交这段期间内，若事务b有插入删除操作，并提交，事务a是可以查询到数量上的变动的。这就造成事务a在一个事务内查询数目的结果不一致。造成幻读。</span><br><span class="line">不可重复读对应的是对一个数据的update操作（事务b update提交前后，事务a查询数据值不一致），而幻读则对应的所对一张表数据的insert操作（事务b insert 提交前后，另一事务a查询个数的不一致）</span><br><span class="line">但mysql采用多版本并发控制（MVCC）解决问题，在mysql中可重复读不会出现幻读现象。</span><br><span class="line">故下图步骤3中数据个数不变。而后在步骤4中将账号111余额增加50时，更新后的余额为150，所在事务b提交结果的基础上增加的。原因所mysql中使用的mvcc控制，select 只是进行快照读（读取历史版本），不回更新为最新版本再去读取。而update,insert,delete等修改操作是会读取数据最新版本的。保证数据的一致性。</span><br></pre></td></tr></table></figure><h6 id="2-4SERIALIZABLE"><a href="#2-4SERIALIZABLE" class="headerlink" title="2.4SERIALIZABLE"></a>2.4SERIALIZABLE</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">顺序读（串行读），解决一切脏读，不可重复度，幻读问题。但事务只能串行执行。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">串行读时，事务b若想进行更新操作，则必须等事务a提交才能进行更新操作，但事务b的读操作比等到事务a提交才能读。也就是说，a,b开启事务后，select * from acct_balance/</span><br><span class="line">select * from acct_balance where account=111会锁住整张表，该锁属于可重入的读锁，对于读读共享，读写，写写排斥</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-总结："><a href="#3-总结：" class="headerlink" title="3.总结："></a>3.总结：</h2><h5 id="四种隔离事务产生问题比较："><a href="#四种隔离事务产生问题比较：" class="headerlink" title="四种隔离事务产生问题比较："></a>四种隔离事务产生问题比较：</h5><p>​                    事务隔离级别               脏读         不可重复度 幻读<br>READ_UNCOMMITTED     ✔                    ✔                 ✔<br>READ_COMMITTED         ×                     ✔                 ✔<br>REPEATABLE_ABLE         ×                     ×                 ✔（mysql中不产生）<br>SERIALIZABLE              ×                     ×                 ×</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
